import pytest
import numpy as np
import binary_code as bc
EPSILON = 1e-6  # error tolerence due to floating number calculation


class Test_BINARY_CODE:
    def test_idxFlatten(self):
        assert bc.idxFlatten([0], [1, 2], 3) == [1, 2]
        assert bc.idxFlatten([0, 1], [2], 3) == [2, 5]
        assert bc.idxFlatten([0, 1], [2, 3], 4) == [2, 3, 6, 7]
        with pytest.raises(ValueError) as excinfo:
            bc.idxFlatten([0, 1], [2, 3], 1)
        assert "y index exceeds column width!" in str(excinfo.value)

    def test_nonUniRandInt(self):
        #  Testing nonUniRandInt extracts non-zero distributions case 0
        dis = [0.28, 0.20, 0.05, 0.0, 0.12, 0.35]
        non_0 = bc.nonUniRandInt(dis)
        assert non_0.lenNonZero == 5
        assert non_0.dis == [0.28, 0.20, 0.05, 0.12, 0.35]
        assert non_0.nonZeroNums == [0, 1, 2, 4, 5]
        assert sum(non_0.disWork) == 0
        biDis = [0.8, 0.92, 0.12, 0.48]
        assert all([abs(non_0.binaryDis[i] - biDis[i]) < EPSILON
                    for i in range(4)])
        assert non_0.firstChoice == [1, 0, 2, 4]
        assert non_0.secondChoice == [0, 2, 5, 5]

        # Testing nonUniRandInt extracts non-zero distributions case 1
        dis = [0.25, 0.25, 0.0, 0.25, 0.25]
        non_1 = bc.nonUniRandInt(dis)
        assert non_1.dis == [0.25, 0.25, 0.25, 0.25]
        assert non_1.nonZeroNums == [0, 1, 3, 4]
        biDis = [0.75, 0.5, 0.25]
        assert all([abs(non_1.binaryDis[i] - biDis[i]) < EPSILON
                    for i in range(3)])
        assert non_1.firstChoice == [0, 1, 3]
        assert non_1.secondChoice == [1, 3, 4]

        # Testing nonUniRandInt extracts non-zero distributions case 2
        dis = [0.15, 0.15, 0.2, 0.25, 0.25]
        non_2 = bc.nonUniRandInt(dis)
        assert non_2.dis == [0.15, 0.15, 0.2, 0.25, 0.25]
        assert non_2.nonZeroNums == [0, 1, 2, 3, 4]
        biDis = [0.6, 0.2, 1, 1]
        assert all([abs(non_2.binaryDis[i] - biDis[i]) < EPSILON
                    for i in range(4)])
        assert non_2.firstChoice == [0, 1, 3, 4]
        assert non_2.secondChoice == [1, 2, 3, 4]

        # Testing the distribution of numbers generated by nonUniRandInt
        # test_num = 1000000
        # bins = [0, 0, 0, 0, 0]
        # for i in range(test_num):
        #     bins[non_2.getNumber()] += 1
        # assert all([abs(non_2.dis[i] - bins[i] / test_num) < 0.01
        #             for i in range(5)])

    def test_primes(self):
        assert bc.primes(2) == [2]
        assert bc.primes(3) == [3]
        assert bc.primes(4) == [2, 2]
        assert bc.primes(6) == [2, 3]
        assert bc.primes(8) == [2, 2, 2]
        assert bc.primes(100) == [2, 2, 5, 5]

    def test_decompose2D(self):
        assert bc.decompose2D(1, 2, 1) == [(1, 1)]
        assert bc.decompose2D(2, 3, 1) == [(2, 1)]
        assert bc.decompose2D(2, 1, 3) == [(1, 2)]

        assert bc.decompose2D(1, 3, 4) == [(1, 1)]
        assert bc.decompose2D(2, 3, 4) == [(1, 2), (2, 1)]
        assert bc.decompose2D(3, 3, 4) == [(1, 3), (3, 1)]
        assert bc.decompose2D(4, 3, 4) == [(1, 4), (2, 2)]
        assert bc.decompose2D(5, 3, 4) == [(1, 4), (2, 2)]
        assert bc.decompose2D(6, 3, 4) == [(2, 3), (3, 2)]
        assert bc.decompose2D(7, 3, 4) == [(2, 3), (3, 2)]
        assert bc.decompose2D(8, 3, 4) == [(2, 4)]
        assert bc.decompose2D(9, 3, 4) == [(3, 3)]
        assert bc.decompose2D(10, 3, 4) == [(3, 3)]
        assert bc.decompose2D(11, 3, 4) == [(3, 3)]
        assert bc.decompose2D(12, 3, 4) == [(3, 4)]
        with pytest.raises(ValueError) as excinfo:
            bc.decompose2D(13, 3, 4)
        assert "input d exceeds numRow * numCol !" in str(excinfo.value)
